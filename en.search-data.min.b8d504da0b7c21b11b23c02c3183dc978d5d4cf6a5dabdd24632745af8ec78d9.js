'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/algorithm/','title':"Algorithm",'content':""});index.add({'id':1,'href':'/docs/coding/','title':"Coding",'content':""});index.add({'id':2,'href':'/docs/development/','title':"Development",'content':""});index.add({'id':3,'href':'/docs/linux/','title':"Linux",'content':"Linux实用操作备忘录 总结一些Linux (Ubuntu) 实用的操作。\n进程悬挂 在使用vim这类编辑器时候经常用到。\n 命令末尾加上 \u0026amp; ，进程后台运行 运行中的前台进程，Ctr+z，转移到后台暂停 fg，将后台进程转至前台 jobs，查看当前悬挂的后台进程 kill %i 杀死第i个进程   快捷操作  ctr+l 等价于clear   防火墙管理 Linux中防火墙规则管理的工具有很多，与iptables相比，ufw和firewalld是更加高级且用户友好的工具。其中firewalld是systemd家族的成员，在CentOS上默认安装。（参考linux-iptables-firewalld）\n# ufw ufw enable|disable ufw allow|deny [service] ufw delete allow [service] 删除某条规则 ufw status # firewalld firewall-cmd --zone=public --add-port=8888/tcp --permanent 添加一个端口 firewall-cmd --reload firewall-cmd --list-all 列出所有规则 firewall-cmd --state 查看状态 # 管理firewalld服务 systemctl enable firewalld systemctl start firewalld systemctl disable firewalld systemctl stop firewalld systemctl status firewalld   查看端口占用 将目前tcp协议监听的端口全部打出来。\n netstat -nltp netstat -anp  参数-n: 打印数值地址, -a: all, -l: only listening, -p: 显示套接字属于的PID和进程名， -t: only tcp, -u: only udp\n vim   i/o等进入编辑模式 v进入可视模式 esc进入命令模式 :wq保存退出，:q!强制退出  显示提示  set nu显示行号，set nonu取消行号 set list显示制表符^I和行尾$，set nolist取消 set fileencoding显示编码  查找替换  / + 要查找的关键词 + enter，查找关键词，按n下一个，N上一个 /^\u0026amp;查找空行 作用范围/old/new/g全文将old替换为new  其中作用范围包括：%s全文范围，s当前行，n,ms第n到m行，.,$s从当前光标处到文末 old和new都是模式匹配，支持正则表达式 最后加上g表示作用到所有匹配，没有则只作用到每行的第一个匹配   :n,ms/^/#将n到m行开头加上注释  命令模式下的编辑  u撤销 V选中全行，x剪切 yy复制当前行，n yy从当前行往后复制n行 p粘贴 dd删除当前行，n+dd往下删除n行，:n,md删除从第n到第m行  编辑模式下的命令  ctrl+w删除一个单词 shift+左右按单词进行左右移动  跳转翻页  ctrl b/f前翻一页/后翻一页 gg跳至文档开头，G跳至文档末尾 w/W按word进行跳转 ^跳至行首，$跳至行末  分屏  vim -O file1 file2同时打开file1和file2，垂直分屏 :vs file2垂直分屏打开file2 vimdiff file1 file2快速定位两个文件不同之处 ctrl w + w分屏跳转 ctrl w + c关闭分屏窗口   服务管理 service nginx status service nginx start|stop|restart  通常需要列出所有服务，查看哪些正在运行，这时就要使用service --status-all。\n注意这里是Ubuntu系统用的是service来管理，CentOS/RHEL 7开始使用systemd服务来代替daemon服务，因此使用systemctl来管理服务。\n 查看进程 ps -ef | grep xxx ps -aux top  查看进程详情可用ll /proc/PID kill -9 PID 杀死进程\n 查看内存/CPU使用 htop   查看GPU信息 lspci | grep VGA  通过lspci命令可以查看所有总线上的设备，在结果中找到VGA（Video Graphic Array）兼容的设备。从结果中可以看到设备在总线上的地址。\nlspci -v -s 00:82.0  通过以上命令可以查看该地址的设备详细信息，包括中断请求（IRQ）号等。\nlshw -C display  也可以直接用lshw命令来查看hardware的信息，通过-C参数指定显示的硬件类型。\nfuser -v /dev/nvidia*  可以通过fuser查看哪些进程在占用GPU。\n 会话管理screen screen实现会话与窗口的解绑。\n screen -S name 创建会话 screen -ls screen -d 2637 detach会话 screen -r 2637 会话恢复 Ctrl-a ddetach当前会话 kill -9 2637 screen -wipe 删除无法连接的会话 在会话中，exit可以退出会话  在一个会话中，可以开多个窗口，发起多个会话。\n 新开一个窗口：ctrl a + shift | 在右边开，ctrl a + S 在左边开 ctrl a + tab 切换窗口 ctrl a + c 初始化窗口 ctrl a + Q 退出窗口   会话管理tmux  前缀键为ctrl b tmux new -s name创建会话 tmux detach or ctrl b + d分离会话与窗口 tmux ls or ctrl b + s查看当前所有会话 tmux attach -t接入会话 tmux kill-session -t杀死会话 tmux switch -t切换会话   系统分区  fdisk 磁盘分区相关操作  fdisk -l 查看当前磁盘信息 fdisk /dev/sda 进行分区建立、删除等操作 创建分区后重启才能生效，之后进行格式化   df -lh 查看系统分区挂载信息 mkfs.ext4 格式化分区  mkfs.ext4 /dev/sda1   mount 挂载分区  mount /dev/sda1 /mydata   umount 卸载分区  umount /dev/sda1     软链接/硬链接 Linux中的文件共享使用通过软链接（符号链接）和硬链接两种方式进行实现。硬链接相当于文件的一个别名，多个文件名对应于同一个索引节点。可以通过link或ln命令进行创建。\nln /home/test/srcfile hardlink  使用时需要注意两点：\n 硬链接只能对文件进行创建，不能对目录进行创建，因为当前目录.和父目录..也是硬链接，会造成目录环。 硬链接不能交叉文件系统创建，因为不同文件系统中会有索引节点号重复的现象。  软连接相当于新建了个文件，数据块里存放的内容即源文件的路径名。不仅没有以上两点限制，还可以进行新的访问权限设置。可以通过以下命令创建。\nln –s /home/test/src softlink  创建链接后，可以通过rm -rf命令进行删除。\n 用户管理  添加：useradd user1  -d指定home目录，-m创建home目录 -g指定用户组 -s指定shell，一般/bin/bash passwd user1为其分配密码   删除：userdel user1  -r删除home目录   用户组  groupadd group1 groupdel group1 修改用户的用户组：usermod -g group1 user1   查看  用户信息：cat /etc/passwd 用户组信息：cat /etc/group     文件传输scp 将本地文件上传至另一台机器：\nscp /home/user1/test.txt user2@x.x.x.x:/home/user2/   -r参数可以实现文件夹拷贝 -i传递私钥 -P指定接受文件服务器端口号（即ssh端口） 同样地还可以实现另一台机器传文件至本地、另外两台机器之间互传文件  scp命令只是简单地在源文件夹和目标文件夹之间进行拷贝。如果需要在网络中使得两个文件夹中内容保持同步，可以使用rsync命令，其delta transfer algorithm可以避免传送已经传送的文件。当需要传输的文件很大时，使用rsync的-P参数可以实现断点重传。一个简单的rsync命令：\nrsync -av -e \u0026quot;ssh -p 21\u0026quot; --progress --rsync-path=\u0026quot;sudo rsync\u0026quot; /src user@host:/dest   -a以递归方式传递文件 -vverbose -e指定ssh方式进行同步 --progress显示备份过程 --rsync-path指定远程服务器上rsync命令的路径，加上sudo即可在远程机器上使用特定权限进行传输，不过这里的sudo rsync命令需要设置成免密码  参考:\nHow does scp differ from rsync?\nrsync命令 RSYNC 以及RSYNC-PATH\n ssh密钥登录 首先通过ssh-keygen生成公钥-私钥对\nssh-keygen -t rsa  参数-t指定生成的密钥类型，通常有rsa和dsa两种，默认保存在~/.ssh/目录下，id_rsa为私钥，id_rsa.pub为公钥。\nOpenSSH 7.0以上版本默认禁用了dsa公钥算法，可能是其密钥长度只有1024位，理论上现在计算机的算力可以将其破解，因此现在建议使用rsa类型密钥，其生成速度相对慢，但验证速度很快，dsa则相反。\n作为服务器端，需要将用户生成的公钥上传到ssh服务器上，并将其内容导入~/.ssh/authorized_keys文件中。（前提是开启了密钥登录）\n作为客户端，可以通过ssh指定私钥路径登录\nssh -i ~/.ssh/id_rsa -p x user@x.x.x.x   find操作大量文件/目录 在Linux中，对大量文件/目录进行操作的时候，往往会报出Argument list too long的错误。这时需要通过find和xargs命令来解决。\nfind ~/path -name \u0026quot;6*\u0026quot; -type d | xargs -i mv {} .  这句命令即是将~/path目录下的以6开头的目录（-type指定类型为目录）移动到当前目录.下面。\n"});index.add({'id':4,'href':'/docs/tools/','title':"Tools",'content':""});index.add({'id':5,'href':'/docs/algorithm/red_black_tree/','title':"Red Black Tree",'content':"红黑树 vs AVL树 红黑树和AVL树都是BST二叉查找树。而且都是为了防止二叉查找树畸形而设计的。最为畸形的二叉查找树查找复杂度是   \\(O(n)\\)  ，即节点连成一线。\n而AVL树和红黑树采取的策略不同。AVL是一种严格的平衡二叉树，不容许左右子树的高度差超过1，其通过平衡因子来控制，在插入和删除节点时，通过左旋和右旋两个操作来调整树的高度。因此其查找复杂度是 \\(O(log_{2}(n))\\)  。因为n个节点的平衡二叉树最多 \\(log_{2}(n)\\)  层，这使得AVL树在查找上是最优的。\n然而，AVL树需要严格维持左右子树的高度差，因此每当插入和删除都需要复杂耗时的旋转操作维护。而作为一种弱平衡二叉树，通常情况下，红黑树的高度高于AVL树，且需要的旋转操作则要少很多，这使得红黑树在保证近似 \\(O(log_{2}(n))\\)  的复杂度情况下能够更加简洁地进行插入和删除操作。因此红黑树更适用于插入、删除较多的场景。\n  红黑树 红黑树并没有严格维持左右子树高度差，而是有自己的规则。\n 每个节点，增加一位以存储节点颜色，非黑即红，根节点为黑。 所有叶子节点（NULL）都是黑色的。 每个红色节点必须有两个黑色子节点，即一条路径上不会有两个连续的红色节点。 任意一节点，到其每个叶子节点的所有路径中，黑色节点数量相同。  以上约束（主要是规则3、4），保证了红黑树最关键的特性：从根节点到叶子节点的最长路径，不会长于最短路径的两倍。这使得红黑树大致平衡，保证了最坏情况下也是高效的。\n应用  JAVA，HashSet，HashMap，TreeSet，TreeMap C++，STL Linux，进程的虚拟内存区 IO多路复用epoll Nginx，定时器  "});index.add({'id':6,'href':'/docs/algorithm/trie/','title':"Trie",'content':"Trie前缀树 最近刷题学习到前缀树，这是一个非常有用的高级数据结构。Trie可用于快速高效查找字符串是否在集合中，只要将这个集合建为一棵Trie，即可以O(n)复杂度查找，n是待查找字符串长度。\n最佳实现 只有字符串末尾节点才挂上word，其余节点为null以作为区分一个节点是否为一个字符串的末尾。\nclass TreeNode{\rTreeNode[] next = new TreeNode[26];\rString word; // 末尾节点挂上word\r}\rclass Trie {\rTreeNode root;\r/** Initialize your data structure here. */\rpublic Trie() {\rroot = new TreeNode();\r}\r/** Inserts a word into the trie. */\rpublic void insert(String word) {\rTreeNode p = root;\rfor(char c : word.toCharArray()){\rint i = c - \u0026#39;a\u0026#39;;\rif(p.next[i] == null) p.next[i] = new TreeNode();\rp = p.next[i];\r}\rp.word = word;\rreturn;\r}\r/** Returns if the word is in the trie. */\rpublic boolean search(String word) {\rTreeNode p = root;\rfor(char c : word.toCharArray()){\rint i = c - \u0026#39;a\u0026#39;;\rif(p.next[i] == null) return false;\relse p = p.next[i];\r}\rreturn p.word != null;\r}\r/** Returns if there is any word in the trie that starts with the given prefix. */\rpublic boolean startsWith(String prefix) {\rTreeNode p = root;\rfor(char c : prefix.toCharArray()){\rint i = c - \u0026#39;a\u0026#39;;\rif(p.next[i] == null) return false;\relse p = p.next[i];\r}\rreturn true;\r}\r}\r这是Java简洁写法，其中insert和search经常用到。\n"});index.add({'id':7,'href':'/docs/coding/java/','title':"Java",'content':"Java Coding Tips Collection相关 遍历Map Map\u0026lt;Integer, Integer\u0026gt; mp = new HashMap\u0026lt;\u0026gt;();\rfor(Map.Entry\u0026lt;Integer, Integer\u0026gt; entry : mp.entrySet()){\rSystem.out.println(entry.getKey());\rSystem.out.println(entry.getValue());\r}\rPriority Queue class Pair implements Comparable\u0026lt;Pair\u0026gt; {\rint a;\rint b;\rPair(int a, int b) {\rthis.a = a;\rthis.b = b;\r}\rpublic int compareTo(Pair o) {\rif(this.a \u0026lt; o.a) return -1;\relse if(this.a == o.a) return 0;\relse return 1;\r}\r}\rQueue\u0026lt;Pair\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;();\rpq.offer(new Pair(1, 2));\rpq.poll();\rpq.size();\rpq.isEmpty();\rpq.peek();\r字符串 String str = \u0026#34;\u0026#34;;\rchar c = str.charAt(i); //第i位元素\rCharacter.isDigit(c); // 判断是否为数字\r// 字符串长度\rstr.length() // different with array\r// 字符串相加\rString str2 = \u0026#34;123\u0026#34;;\rstr = str + str2;\r// **也能用StringBuilder拼接\rStringBuilder sb = new StringBuilder();\rsb.append(str);\rsb.append(str2);\rsb.toString();\r// 删除字符串最后一个字符\rstr = str.substring(0, str.length()-1);\r// 字符串转换为字符数组\rstr.toCharArray();\rsplit String[] strs = str.split(\u0026#34;,\u0026#34;); //与python用法类似\rjoin List\u0026lt;String\u0026gt; strList = Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;);\rString str = String.join(\u0026#34;, \u0026#34;, strList);\rString[] strArr = new String[]{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;};\rstr = String.join(\u0026#34;, \u0026#34;, strArr);\r互转 字符串与数字互转 String str = \u0026#34;1234\u0026#34;;\rint num = Integer.parseInt(str);\rstr = String.valueOf(num)\r数组与List互转 int[] arr = new int[]{1, 2, 3};\rList\u0026lt;Integer\u0026gt; list = Arrays.asList(arr);\rarr = list.toArray();\r"});index.add({'id':8,'href':'/docs/coding/python/','title':"Python",'content':"Python Notes map对象 在Python2中, map返回的是一个list，在Python3中，map返回的是一个map对象，而map对象只能迭代一轮，每次迭代都会返回一个新的迭代器，迭代完所有元素后就变成空的对象了。所以如果需要对其进行多轮迭代，那需要将map对象转换为list。\ndata = list(map(str.strip, open(file_path).readlines()))\rvideoset = [x.split()[0] for x in data]\rfilenames = [x.split()[1] for x in data]\rconda虚拟环境管理 conda env list 查看当前存在的环境\rconda list 查看当前环境装的包\rconda create -n env_name python=2.7 创建环境\rconda remove -n env_name --all 删除环境\rconda activate env_name 激活环境\rconda deactivate 退出环境\r jupyter notebook kernel安装 conda activate env_name 先激活该环境\rpython -m ipykernel install --user --name kernel_name 安装kernel\r memmap处理大数组 很多时候我们会遇到要处理的数组过大，而内存不足的问题，这时候就需numpy.memmap。\n# 创建test.dat文件\r f = np.memmap(\u0026#39;test.dat\u0026#39;, dtype=np.float32, mode=\u0026#39;w+\u0026#39;, shape=(nrows, ncols))\r# 对f进行修改\r for i in range(nrows):\rf[i, :] = np.random.rand(ncols)\rdel f\r# del之后内存中的数组就同步到了磁盘上，这样内存映射的file就已经创建好了\r # 读取保存好的数据\r f = np.memmap(\u0026#39;test.dat\u0026#39;, dtype=np.float32, mode=\u0026#39;r\u0026#39;, shape=(nrows, ncols))\r虚拟环境 python -m venv tutorial-env source tutorial-env/bin/activate\rpip freeze \u0026gt; requirements.txt pip install -r requirements.txt\r make a plot A good way to make a plot is to look at the Matplotlib gallery, find a plot that looks somewhat like what you want, and adapt the code they give.\n"});index.add({'id':9,'href':'/docs/development/django/','title':"Django",'content':"Django项目搭建流程 Django是Python的一个基于MTV（Model-Template-View）模式的后端框架。其提供了搭建网站的一系列的解决方案，给我们开发提供了很多便捷，包括后台管理（admin）、登录验证(auth)、表单处理(Form)等等，因此其可能使用起来没有Flask那么轻巧。\n本文仅介绍传统Django项目的搭建流程，即后端渲染页面，生成一个html返回给前端。当然，现在出现了前后端分离的架构，后端只负责对数据进行处理，然后提供一个REST API，将处理好的数据用json的格式返回给前端，前端用JavaScript来渲染页面。前端渲染页面时不用对整个页面进行渲染，采用Diff算法，只将有更新的元素进行重新渲染，提升了性能。\n创建项目 django-admin startproject 项目名\r  manage.py: 与创建好的项目进行命令交互的工具 __init__.py：空文件，告诉Python该目录可被看作一个包 settings.py：项目配置文件 urls.py：项目URL声明 wsgi.py：项目与WSGI兼容的Web服务器入口  数据库配置  在__init__.py中写入  import pymysql\rpymysql.install_as_MySQLdb()\r 在settings.py里面的DATABASES里面配置\n ENGINE里的sqlite改为mysql\rNAME：“数据库名”\rUSER：“用户名”\rPASSWORD：密码\rHOST：服务器ip\rPORT：端口\r   创建应用 python manage.py startapp app名\r  admin.py：站点配置 models.py：模型 views.py：视图  激活应用 在settings.py中将自己的应用名加入到INSTALLED_APPS中\n定义模型  一个数据表就对应一个模型(类) 在models.py文件中定义模型 模型类要继承models.Model类  class Grades(models.Model):\rgname = models.CharField(max_length=20)\rgdate = models.DateTimeField()\rggirlnum = models.IntegerField()\rsgrade = models.ForeignKey(\u0026#34;Grades\u0026#34;)\r生成数据表   生成迁移文件\n python manage.py makemigrations\r 在migrations目录下生成一个迁移文件\n  执行迁移\n python manage.py migrate\r 相当于执行SQL创建数据表\n  测试数据操作   进入python shell\n python manage.py shell\r   引入包\n from myApp.models import Grades, Students\rfrom django.utils import timezone\rfrom datetime import *\r   查询所有数据\n Grades.objects.all()\r   添加数据（创建一个模型类的对象实例）\n grade = Grades()\rgrade.gname = \u0026quot;abc\u0026quot;\rgrade.gdate = datetime(year = 2019, month = 3, day = 21)\rgrade.save()\r   查看某个对象\n classname.object.get(pk = 2)\r   修改数据\n obj.attr1 = newValue\robj.save()\r   删除数据\n obj.delete()\r   关联对象\n grade = Grades.object.get(pk = 1)\rstu = Students()\rstu.sgrade = grade\rstu.save()\r   获得关联对象的集合\n obj.关联的类名小写_set.all()\rgrade.students_set.all()\r 例如，把stu2插入到grade班级：\n stu2 = grade.students_set.create(属性名 = 值)\r 不用save，直接插入数据库。\n  启动服务器 python manage.py runserver ip:port\r 这里ip可以不写，代表本地测试ip (127.0.0.1)，端口号默认8000\n这是一个纯python的轻量级web服务器，仅仅在开发测试中使用\nadmin站点管理 配置admin应用 在settings.py文件中的INSTALLED_APPS中添加‘django.contrib.admin’\n创建管理员、用户 python manage.py createsuperuser\r 输入用户名、邮箱密码\n中文支持 在settings.py里设置\nLANGUAGE_CODE = ‘zh-Hans’\rTIME_ZONE = ‘Asia/Shanghai’\r 管理数据表: 修改admin.py文件\nfrom .models import Grades, Students\radmin.site.register(Grades)\radmin.site.register(Students)\r自定义管理页面 列表页属性（4个）、添加修改页属性（2个）\nclass GradesAdmin(admin.ModelAdmin):\rlist_display = [\u0026#39;pk\u0026#39;, \u0026#39;gname\u0026#39;, ... ]\rlist_filter = [\u0026#39;gname\u0026#39; ]\rsearch_fields = [\u0026#39;gname\u0026#39; ]\rlist_per_page = 5\r#fields = [ ]\r fieldsets = [ (\u0026#34;num\u0026#34;, {\u0026#34;fields\u0026#34;: [\u0026#39;ggirlnum\u0026#39;,\u0026#39;gboynum\u0026#39;]}),\r(\u0026#34;base\u0026#34;, {\u0026#34;fields\u0026#34;: [\u0026#39;gname\u0026#39;, \u0026#39;gdate\u0026#39;, \u0026#39;isDelete\u0026#39;]}), ]\radmin.site.register(Grades, GradesAdmin)\r关联对象 例如，在添加一个班级时可以添加几个学生\nclass StudentInfo(admin.TabularInline): #StackedInline\r model = Student\rextra = 2\rclass GradesAdmin(admin.ModelAdmin):\rinlines = [StudentsInfo]\r布尔值显示问题 class StudentAdmin(admin.ModelAdmin):\rdef gender(self):\rif self.sgender:\rreturn \u0026#34;男\u0026#34;\relse:\rreturn \u0026#34;女\u0026#34;\r# 设置页面列的名称\r gender.short_description = \u0026#34;性别\u0026#34;\rlist_display = [\u0026#39;pk\u0026#39;, \u0026#39;sname\u0026#39;, \u0026#39;sage\u0026#39;, gender, \u0026#39;sgrade\u0026#39;]\rlist_per_page = 10\radmin.site.register(Students, StudentsAdmin)\r执行动作位置问题 actions_on_top = False\ractions_on_bottom = True\r使用装饰器完成注册 把之前的admin.site.register(Students, StudentsAdmin)注释，在上面添加 @admin.register(Students)\n视图的基本使用  在django中，视图对web请求进行回应 视图就是python函数，在views.py文件中定义  定义视图 from django.http import HttpResponse\rdef index(request):\rreturn HttpResponse(\u0026#34;Hello world!\u0026#34;)\r配置URL  修改project目录下的urls.py文件  from django.conf.urls import url, include\rfrom django.contrib import admin\rurlpatterns = [\rurl(r\u0026#39;^admin/\u0026#39;, admin.site.urls),\rurl(r\u0026#39;^\u0026#39;, include(\u0026#39;myApp.urls\u0026#39;)),\r]\r在myApp应用目录下创建一个urls.py文件  from django.conf.urls import url\rfrom . import views\rurlpatterns = [\rurl(r\u0026#39;^$\u0026#39;, views.index)\r]\r模板的基本使用 模板是HTML页面，可根据视图中传递过来的数据进行填充。\n创建模板目录 创建templates目录，在目录下创建对应项目的模板目（e.g., project/templates/myApp）\n配置模板路径 修改settings.py文件下的TEMPLATES\n'DIRS' : [os.path.join(BASE_DIR, 'templates')]\r 模板语法 {{输出值，可以是变量，也可以是对象属性}}\r{%执行代码段%}\r 使用流程 写html模板-\u0026gt;定义视图-\u0026gt;配置url\n"});index.add({'id':10,'href':'/docs/development/restful/','title':"Restful",'content':"RESTful架构 本篇是我学习RESTful的笔记。\n RESTful，即Representational State Transfer，表现层状态转换。以资源为导向，每个URI(统一资源标识符)标识一个资源，对应有get/post/put/delete方法。\n（URL(统一资源定位符)是URI最普遍的的一种形式，URI包括URL和URN(统一资源名)）\n传统的Web后端仅仅是以方法为导向，后端写了N个方法，每个路由映射到一个方法，用于处理请求。\nResources REST其实是资源的表现层状态转化，资源是网络中的一个实体，可以是文本、图片、音频等，用URI来进行唯一定位。\nRepresentation 资源的表现层，即呈现出来的形式，文本可以是用txt、xml、json、html等多种形式呈现出来。\nState Transfer 状态转换是指资源表现层的状态转换，用户是通过HTTP协议来与服务器进行交互，以操控网络中的资源，使其表现层发生状态转化（比如查插删改）。正好可以用HTTP的四个动作GET/POST/PUT/DELETE来完成。\n小结  每个URI代表一种资源。 用户通过GET/POST/PUT/DELETE实现资源的表现层状态转化。  注意事项  URI表示资源，不该包含动词。动作由HTTP协议的GET/POST/PUT/DELETE来加以区分。 URI中不包含版本号，版本号通过HTTP请求头中的Accept字段区分。  "});index.add({'id':11,'href':'/docs/tools/beamer/','title':"Beamer",'content':"Beamer Beamer是一个简单高效的LaTeX Slides模板，用其制作学术PPT会更加简洁美观。这里是一个Beamer模板，包括文档结构搭建、分栏、模块化文本、参考文献引用、算法编写、字体设置以及图片插入等功能的实现。\n 环境配置：CTeX + vscode + LaTeX Workshop插件 参考文档：beameruserguide 初始文档结构：  整体框架 \\documentclass{beamer}\r\\usetheme{EastLansing} % Beamer主题样式v 3.0\r\\usecolortheme{rose} % Beamer颜色主题样式\r\\usefonttheme[onlylarge]{structuresmallcapsserif}\r\\title[]{} % 缩写，全写\r\\author[]{}\r\\institute[]{}\r\\begin{document}\r\\begin{frame}\r\\titlepage\r\\end{frame}\r\\section*{Outline}\r\\begin{frame}\r\\tableofcontents\r\\end{frame}\r\\section{Introduction}\r\\subsection{Overview}\r\\begin{frame}\r\\frametitle{}\r%\\framesubtitle{}\r Content\r\\end{frame}\r\\end{document}\r加外框的文本 % definition\r\\begin{definition}\rdefinition...\r\\end{definition}\r% example\r\\begin{example}\r\\begin{itemize}\r\\item emample1\r\\item emample2\r\\end{itemize}\r\\end{example}\r% block\r\\begin{block}{Answered Questions}\rHow many primes are there?\r\\end{block}\r% proof\r\\begin{proof}\r\\end{proof}\r分栏 \\begin{columns}\r\\column{.5\\textwidth}\r\\begin{block}{Answered Questions}\rHow many primes are there?\r\\end{block}\r\\column{.5\\textwidth}\r\\begin{block}{Open Questions}\rIs every even number the sum of two primes?\r\\end{block}\r\\end{columns}\r参考文献 \\begin{thebibliography}{10}\r\\bibitem{Goldbach1742}[Goldbach, 1742]\rChristian Goldbach.\r\\newblock A problem we should try to solve before the ISPN ’43 deadline,\r\\newblock \\emph{Letter to Leonhard Euler}, 1742.\r\\end{thebibliography}\r\\cite{Goldbach1742}\r算法编写 \\usepackage{algorithm} % 导入相关包\r\\usepackage{algorithmic}\r\\renewcommand{\\algorithmicrequire}{\\textbf{Input:}} % 修改关键字为Input和Output\r\\renewcommand{\\algorithmicensure}{\\textbf{Output:}}\r\\begin{algorithm}[H]\r\\caption{\\scshape{stacking}}\r\\label{alg1} \\begin{algorithmic}[1] % 此处的[1]控制一下算法中的每句前面都有标号 \r\\REQUIRE sampled set: $\\mathcal{S}$; iteration depth: $K$; neighborhood function: $\\mathcal{N}$; features of nodes: $\\pmb{x}_{u}, u \\in \\mathcal{S}^{0}$ % Input\r\r\\ENSURE final embeddings: $\\pmb{z}_{u}$, $u \\in \\mathcal{S}^{K}$ % Output\r\r% if-then-else \\IF{condition1} \\STATE do somthing\r\\ELSIF{condition2} \\STATE do somthing \\ELSE \\STATE do somthing else\r\\ENDIF % for loop \\FOR{$k = 1$ to $K$} \\STATE do iteration \\ENDFOR\r% forall loop\r\\FORALL{$i$ such that $0\\leq i\\leq 10$} \\STATE do iteration \\ENDFOR % while-loop \\WHILE{condition holds} \\STATE do iteration \\ENDWHILE % repeat-until loop \\REPEAT \\STATE do iteration \\UNTIL{condition break}\r% infinite loop \\LOOP \\STATE do something repeated forever \\ENDLOOP\r\\end{algorithmic} \\end{algorithm} 字体 % 数学符号字体\r\\usepackage{mathrsfs}\r$\\mathcal{G(V,E)}$ % 花体\r$\\mathbb{E}$ % 空心字体\r$\\pmb{z}$ % 矢量加粗\r\r% 普通字体\r\\scshape{convolve} % 小型大写\r\\upshape{ReLU} % 直立\r\\emph{random walk} % 倾斜\r\\textbf{keys} % 加粗\r\\alert{scores}\r插入图片 \\begin{center}\r\\includegraphics[height=4cm]{figs/offlinetest.png}\\\\\r\\end{center} "});index.add({'id':12,'href':'/docs/tools/git/','title':"Git",'content':"Git学习手册 总结了一些Git的常规操作，以便以后查看使用。\n本地仓库 首先得有个本地仓库，可由两种方法创建。\n$ git init\rgit init在当前目录创建一个仓库，并自动创建一个master分支。\n$ git clone [url]\r或者，将源程仓库从[url]clone下来，并将其全部分支和commit历史全部都一并clone下来。\n如果想要直接把项目文件放到当前文件夹下，可以使用：\n$ git clone [url] .\r这样当前目录就成为了一个仓库，存在一个.git文件夹。\n配置账户信息 如果是第一次使用Git，需要在git commit之前设置一下用户名和密码，这将在commit时用于身份识别。\n$ git config --global user.name \u0026#34;your username\u0026#34;\r$ git config --global user.email \u0026#34;your email address\u0026#34;\r配置好了之后，可以通过git config --list，查看 git 的全局用户名和邮箱。\n$ git config --list\r分支 得有一个分支，分支是版本控制的核心。master是默认创建的分支，也是主分支，其中存放的一般是deployment级别的代码。做修改一般会创建自己的分支。\n$ git branch [branch-name]\r查看当前分支。\n$ git status\r切换当前分支。\n$ git checkout [branch-name]\r管理本地与远程分支 将某（远程 or 本地）分支合并到当前本地分支。\n$ git merge [branch-name]\r查看本地和远程各有哪些分支。\n$ git branch -a\r删除远程分支。\n$ git push origin --delete [remote-branch-name]\r删除本地分支。\n$ git branch -d [branch-name]\r从远程仓库获取更改 首先用git remote查看下本地配置了哪些源程服务器。\n$ git remote -v\r然后用git fetch将源程仓库中更改的文件获取到本地仓库。origin是个远程仓库的默认shotname。\n$ git fetch origin\r用git merge将fetch下来的远程仓库与本地仓库进行合并。以remotename/branchname形式规定将哪个远程仓库的哪个分支与本地的代码进行合并。\n$ git merge origin/master\rgit pull将git fetch和git merge合二为一。以remotename branchname规定要合并的分支。\n$ git pull origin master\r更改本地仓库 对本地的代码进行一定修改后，要先git add到本地仓库中，然后git commit。\n$ git add -A\r$ git commit -m \u0026#34;describe this commit\u0026#34;\r查看历史操作和回退版本 先查看一下当前分支的所有历史版本。\n$ git log\r找到想要退回的版本号（commit），然后用reset进行回退。\n$ git reset --hard [commit]\r$ git reset --soft [commit]\r其中--hard是回退到该版本，并且本地代码也重置到该版本。--soft是仅回退到该版本，本地代码仍然不动。\n合并冲突与撤销 合并的时候会进行到一半突然出现一个合并冲突，这很常见，是因为两个人都对同一个文件进行的不同的修改。\n$ git merge --abort\r可以在发生冲突时先用--abort终止合并，退回到合并之前的状态，将冲突的地方协商修改后，再进行合并。\n若合并后发现了一些错误，可以通过上述的git reset --hard回退到上一版本。\n将本地仓库代码上传到远程仓库 将本地仓库的某指定分支上传到远程仓库的某指定分支。\n$ git push origin master:master\r小结 最重要的是要有仓库和分支两个概念。仓库和分支都有本地和远程之分。本地仓库可以通过git init,git branch,git checkout,git add,git commit, git merge, git reset等进行操作。\n对远程仓库，可以用git remote, git fetch, git merge, git pull, git push来进行操作。\n其核心是，将远程clone到本地，对本地进行修改，通过分支和版本来进行版本控制，最后与远程进行同步。\n"});index.add({'id':13,'href':'/posts/','title':"Blog",'content':""});index.add({'id':14,'href':'/docs/','title':"Docs",'content':""});})();