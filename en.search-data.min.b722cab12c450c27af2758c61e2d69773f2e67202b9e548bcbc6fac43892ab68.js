'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/algorithm/','title':"Algorithm",'content':""});index.add({'id':1,'href':'/docs/development/','title':"Development",'content':""});index.add({'id':2,'href':'/docs/linux/','title':"Linux",'content':"Linux实用操作备忘录 总结一些Linux (Ubuntu) 实用的操作。\n进程悬挂 在使用vim这类编辑器时候经常用到。\n 命令末尾加上 \u0026amp; ，进程后台运行 运行中的前台进程，Ctr+z，转移到后台暂停 fg，将后台进程转至前台 jobs，查看当前悬挂的后台进程 kill %i 杀死第i个进程   快捷操作  ctr+l 等价于clear   防火墙 ufw enable|disable ufw allow|deny [service] ufw delete allow [service] 删除某条规则 ufw status   查看端口占用 将目前tcp协议监听的端口全部打出来。\n netstat -nltp netstat -anp  参数-n: 打印数值地址, -a: all, -l: only listening, -p: 显示套接字属于的PID和进程名， -t: only tcp, -u: only udp\n vim   i/o等进入编辑模式 esc进入命令模式 命令模式下，/ + 要查找的关键词 + enter，查找关键词，按n下一个 G和gg分别跳至开头/末尾 :wq保存退出，:q!强制退出   服务管理 service nginx status service nginx start|stop|restart  通常需要列出所有服务，查看哪些正在运行，这时就要使用service --status-all。\n注意这里是Ubuntu系统用的是service来管理，CentOS/RHEL 7开始使用systemd服务来代替daemon服务，因此使用systemctl来管理服务。\n 查看进程 ps -ef | grep xxx ps -aux top  查看进程详情可用ll /proc/PID\nkill -9 PID 杀死进程\n 查看内存/CPU使用 htop  "});index.add({'id':3,'href':'/docs/tools/','title':"Tools",'content':""});index.add({'id':4,'href':'/docs/algorithm/red_black_tree/','title':"Red Black Tree",'content':"红黑树 vs AVL树 红黑树和AVL树都是BST二叉查找树。而且都是为了防止二叉查找树畸形而设计的。最为畸形的二叉查找树查找复杂度是   \\(O(n)\\)  ，即节点连成一线。\n而AVL树和红黑树采取的策略不同。AVL是一种严格的平衡二叉树，不容许左右子树的高度差超过1，其通过平衡因子来控制，在插入和删除节点时，通过左旋和右旋两个操作来调整树的高度。因此其查找复杂度是 \\(O(log_{2}(n))\\)  。因为n个节点的平衡二叉树最多 \\(log_{2}(n)\\)  层，这使得AVL树在查找上是最优的。\n然而，AVL树需要严格维持左右子树的高度差，因此每当插入和删除都需要复杂耗时的旋转操作维护。而作为一种弱平衡二叉树，通常情况下，红黑树的高度高于AVL树，且需要的旋转操作则要少很多，这使得红黑树在保证近似 \\(O(log_{2}(n))\\)  的复杂度情况下能够更加简洁地进行插入和删除操作。因此红黑树更适用于插入、删除较多的场景。\n  红黑树 红黑树并没有严格维持左右子树高度差，而是有自己的规则。\n 每个节点，增加一位以存储节点颜色，非黑即红，根节点为黑。 所有叶子节点（NULL）都是黑色的。 每个红色节点必须有两个黑色子节点，即一条路径上不会有两个连续的红色节点。 任意一节点，到其每个叶子节点的所有路径中，黑色节点数量相同。  以上约束（主要是规则3、4），保证了红黑树最关键的特性：从根节点到叶子节点的最长路径，不会长于最短路径的两倍。这使得红黑树大致平衡，保证了最坏情况下也是高效的。\n应用  JAVA，HashSet，HashMap，TreeSet，TreeMap C++，STL Linux，进程的虚拟内存区 IO多路复用epoll Nginx，定时器  "});index.add({'id':5,'href':'/docs/algorithm/trie/','title':"Trie",'content':"Trie前缀树 最近刷题学习到前缀树，这是一个非常有用的高级数据结构。Trie可用于快速高效查找字符串是否在集合中，只要将这个集合建为一棵Trie，即可以O(n)复杂度查找，n是待查找字符串长度。\n最佳实现 只有字符串末尾节点才挂上word，其余节点为null以作为区分一个节点是否为一个字符串的末尾。\nclass TreeNode{\rTreeNode[] next = new TreeNode[26];\rString word; // 末尾节点挂上word\r}\rclass Trie {\rTreeNode root;\r/** Initialize your data structure here. */\rpublic Trie() {\rroot = new TreeNode();\r}\r/** Inserts a word into the trie. */\rpublic void insert(String word) {\rTreeNode p = root;\rfor(char c : word.toCharArray()){\rint i = c - \u0026#39;a\u0026#39;;\rif(p.next[i] == null) p.next[i] = new TreeNode();\rp = p.next[i];\r}\rp.word = word;\rreturn;\r}\r/** Returns if the word is in the trie. */\rpublic boolean search(String word) {\rTreeNode p = root;\rfor(char c : word.toCharArray()){\rint i = c - \u0026#39;a\u0026#39;;\rif(p.next[i] == null) return false;\relse p = p.next[i];\r}\rreturn p.word != null;\r}\r/** Returns if there is any word in the trie that starts with the given prefix. */\rpublic boolean startsWith(String prefix) {\rTreeNode p = root;\rfor(char c : prefix.toCharArray()){\rint i = c - \u0026#39;a\u0026#39;;\rif(p.next[i] == null) return false;\relse p = p.next[i];\r}\rreturn true;\r}\r}\r这是Java简洁写法，其中insert和search经常用到。\n"});index.add({'id':6,'href':'/docs/development/restful/','title':"Restful",'content':"RESTful架构 本篇是我学习RESTful的笔记。\n RESTful，即Representational State Transfer，表现层状态转换。以资源为导向，每个URI(统一资源标识符)标识一个资源，对应有get/post/put/delete方法。\n（URL(统一资源定位符)是URI最普遍的的一种形式，URI包括URL和URN(统一资源名)）\n传统的Web后端仅仅是以方法为导向，后端写了N个方法，每个路由映射到一个方法，用于处理请求。\nResources REST其实是资源的表现层状态转化，资源是网络中的一个实体，可以是文本、图片、音频等，用URI来进行唯一定位。\nRepresentation 资源的表现层，即呈现出来的形式，文本可以是用txt、xml、json、html等多种形式呈现出来。\nState Transfer 状态转换是指资源表现层的状态转换，用户是通过HTTP协议来与服务器进行交互，以操控网络中的资源，使其表现层发生状态转化（比如查插删改）。正好可以用HTTP的四个动作GET/POST/PUT/DELETE来完成。\n小结  每个URI代表一种资源。 用户通过GET/POST/PUT/DELETE实现资源的表现层状态转化。  注意事项  URI表示资源，不该包含动词。动作由HTTP协议的GET/POST/PUT/DELETE来加以区分。 URI中不包含版本号，版本号通过HTTP请求头中的Accept字段区分。  "});index.add({'id':7,'href':'/docs/tools/beamer/','title':"Beamer",'content':"Beamer Beamer是一个简单高效的LaTeX Slides模板，用其制作学术PPT会更加简洁美观。这里是一个Beamer模板，包括文档结构搭建、分栏、模块化文本、参考文献引用、算法编写、字体设置以及图片插入等功能的实现。\n 环境配置：CTeX + vscode + LaTeX Workshop插件 参考文档：beameruserguide 初始文档结构：  整体框架 \\documentclass{beamer}\r\\usetheme{EastLansing} % Beamer主题样式v 3.0\r\\usecolortheme{rose} % Beamer颜色主题样式\r\\usefonttheme[onlylarge]{structuresmallcapsserif}\r\\title[]{} % 缩写，全写\r\\author[]{}\r\\institute[]{}\r\\begin{document}\r\\begin{frame}\r\\titlepage\r\\end{frame}\r\\section*{Outline}\r\\begin{frame}\r\\tableofcontents\r\\end{frame}\r\\section{Introduction}\r\\subsection{Overview}\r\\begin{frame}\r\\frametitle{}\r%\\framesubtitle{}\r Content\r\\end{frame}\r\\end{document}\r加外框的文本 % definition\r\\begin{definition}\rdefinition...\r\\end{definition}\r% example\r\\begin{example}\r\\begin{itemize}\r\\item emample1\r\\item emample2\r\\end{itemize}\r\\end{example}\r% block\r\\begin{block}{Answered Questions}\rHow many primes are there?\r\\end{block}\r% proof\r\\begin{proof}\r\\end{proof}\r分栏 \\begin{columns}\r\\column{.5\\textwidth}\r\\begin{block}{Answered Questions}\rHow many primes are there?\r\\end{block}\r\\column{.5\\textwidth}\r\\begin{block}{Open Questions}\rIs every even number the sum of two primes?\r\\end{block}\r\\end{columns}\r参考文献 \\begin{thebibliography}{10}\r\\bibitem{Goldbach1742}[Goldbach, 1742]\rChristian Goldbach.\r\\newblock A problem we should try to solve before the ISPN ’43 deadline,\r\\newblock \\emph{Letter to Leonhard Euler}, 1742.\r\\end{thebibliography}\r\\cite{Goldbach1742}\r算法编写 \\usepackage{algorithm} % 导入相关包\r\\usepackage{algorithmic}\r\\renewcommand{\\algorithmicrequire}{\\textbf{Input:}} % 修改关键字为Input和Output\r\\renewcommand{\\algorithmicensure}{\\textbf{Output:}}\r\\begin{algorithm}[H]\r\\caption{\\scshape{stacking}}\r\\label{alg1} \\begin{algorithmic}[1] % 此处的[1]控制一下算法中的每句前面都有标号 \r\\REQUIRE sampled set: $\\mathcal{S}$; iteration depth: $K$; neighborhood function: $\\mathcal{N}$; features of nodes: $\\pmb{x}_{u}, u \\in \\mathcal{S}^{0}$ % Input\r\r\\ENSURE final embeddings: $\\pmb{z}_{u}$, $u \\in \\mathcal{S}^{K}$ % Output\r\r% if-then-else \\IF{condition1} \\STATE do somthing\r\\ELSIF{condition2} \\STATE do somthing \\ELSE \\STATE do somthing else\r\\ENDIF % for loop \\FOR{$k = 1$ to $K$} \\STATE do iteration \\ENDFOR\r% forall loop\r\\FORALL{$i$ such that $0\\leq i\\leq 10$} \\STATE do iteration \\ENDFOR % while-loop \\WHILE{condition holds} \\STATE do iteration \\ENDWHILE % repeat-until loop \\REPEAT \\STATE do iteration \\UNTIL{condition break}\r% infinite loop \\LOOP \\STATE do something repeated forever \\ENDLOOP\r\\end{algorithmic} \\end{algorithm} 字体 % 数学符号字体\r\\usepackage{mathrsfs}\r$\\mathcal{G(V,E)}$ % 花体\r$\\mathbb{E}$ % 空心字体\r$\\pmb{z}$ % 矢量加粗\r\r% 普通字体\r\\scshape{convolve} % 小型大写\r\\upshape{ReLU} % 直立\r\\emph{random walk} % 倾斜\r\\textbf{keys} % 加粗\r\\alert{scores}\r插入图片 \\begin{center}\r\\includegraphics[height=4cm]{figs/offlinetest.png}\\\\\r\\end{center} "});index.add({'id':8,'href':'/docs/tools/git/','title':"Git",'content':"Git学习手册 总结了一些Git的常规操作，以遍以后查看使用。\n本地仓库 首先得有个本地仓库，可由两种方法创建。\n$ git init\rgit init在当前目录创建一个仓库，并自动创建一个master分支。\n$ git clone [url]\r或者，将源程仓库从[url]clone下来，并将其全部分支和commit历史全部都一并clone下来。\n分支 得有一个分支，分支是版本控制的核心。master是默认创建的分支，也是主分支，其中存放的一般是deployment级别的代码。做修改一般会创建自己的分支。\n$ git branch [branch-name]\r查看当前分支。\n$ git status\r切换当前分支。\n$ git checkout [branch-name]\r管理本地与远程分支 将某（远程 or 本地）分支合并到当前本地分支。\n$ git merge [branch-name]\r查看本地和远程各有哪些分支。\n$ git branch -a\r删除远程分支。\n$ git push origin --delete [remote-branch-name]\r删除本地分支。\n$ git branch -d [branch-name]\r从远程仓库获取更改 首先用git remote查看下本地配置了哪些源程服务器。\n$ git remote -v\r然后用git fetch将源程仓库中更改的文件获取到本地仓库。origin是个远程仓库的默认shotname。\n$ git fetch origin\r用git merge将fetch下来的远程仓库与本地仓库进行合并。以remotename/branchname形式规定将哪个远程仓库的哪个分支与本地的代码进行合并。\n$ git merge origin/master\rgit pull将git fetch和git merge合二为一。以remotename branchname规定要合并的分支。\n$ git pull origin master\r更改本地仓库 对本地的代码进行一定修改后，要先git add到本地仓库中，然后git commit。\n$ git add -A\r$ git commit -m \u0026#34;describe this commit\u0026#34;\r查看历史操作和回退版本 先查看一下当前分支的所有历史版本。\n$ git log\r找到想要退回的版本号（commit），然后用reset进行回退。\n$ git reset --hard [commit]\r$ git reset --soft [commit]\r其中--hard是回退到该版本，并且本地代码也重置到该版本。--soft是仅回退到该版本，本地代码仍然不动。\n合并冲突与撤销 合并的时候会进行到一半突然出现一个合并冲突，这很常见，是因为两个人都对同一个文件进行的不同的修改。\n$ git merge --abort\r可以在发生冲突时先用--abort终止合并，退回到合并之前的状态，将冲突的地方协商修改后，再进行合并。\n若合并后发现了一些错误，可以通过上述的git reset --hard回退到上一版本。\n将本地仓库代码上传到远程仓库 将本地仓库的某指定分支上传到远程仓库的某指定分支。\n$ git push origin master:master\r小结 最重要的是要有仓库和分支两个概念。仓库和分支都有本地和远程之分。本地仓库可以通过git init,git branch,git checkout,git add,git commit, git merge, git reset等进行操作。\n对远程仓库，可以用git remote, git fetch, git merge, git pull, git push来进行操作。\n其核心是，将远程clone到本地，对本地进行修改，通过分支和版本来进行版本控制，最后与远程进行同步。\n"});index.add({'id':9,'href':'/posts/','title':"Blog",'content':""});index.add({'id':10,'href':'/docs/','title':"Docs",'content':""});})();